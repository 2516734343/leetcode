# 算法思想

## 二分查找

- 概念：对具有指定左索引和右索引的连续序列进行操作。
- 如何工作的？引用 leetcode 官网的介绍：
  > 二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。
- 二分查找一般分为 3 部分：
  - **预处理** 如果要处理的集合没有排序，需要先排序。
  - **二分查找** 利用循环或者递归在每次比较后讲查找空间划分为两半。
  - **后处理** 在剩余的空间中确定可行的候选者。

[leetcode 之二分查找](https://leetcode-cn.com/leetbook/detail/binary-search/)

## 双指针

## 排序

# 数组

特点：

- 连续存储。
- 通过索引可以访问到

## 1. 前缀和

适用于快速、频繁的计算一个索引区间内元素的和。

## 2. 查分数组

# 二叉树

> 所有回溯、动归、分治算法，其实都是树 的问题，⽽树的问题就永远逃不开树的**递归遍历**

## 二叉树的遍历：

- 前序遍历(DLR)，
- 中序遍历(LDR)，
- 后序遍历(LRD).

**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定 义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节。**

写树相关的算法，简单说就是，**先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数 定义递归调⽤⼦节点**，递归调⽤会让孩⼦节点做相同的事情。

**所谓「该做什么」就是让你想清楚写什么代码能够实现题⽬想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。**

**⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情。**

如果当前节点要做的事情需要通过左右⼦树的计算结果推导出来，就要⽤到后序遍历。**我们要尽可能避免递归函数中调⽤其他递归函数。**

- 226. 翻转⼆叉树（简单）---前序
- 114. ⼆叉树展开为链表（中等）---后序
- 116. 填充每个节点的下⼀个右侧节点指针（中等）--- 前序
- 654. 最⼤⼆叉树（中等）
- 105. 从前序与中序遍历序列构造⼆叉树（中等）
- 106. 从中序与后序遍历序列构造⼆叉树（中等）
- 1373. ⼆叉搜索⼦树的最⼤键值和（困难）

## 二叉树的序列化

⼆叉树结该是⼀个⼆维平⾯内的结构，⽽序列化出来的字符串是⼀个线性的⼀维结构。**所谓的序 列化不过就是把结构化的数据「打平」，其实就是在考察⼆叉树的遍历⽅式。**

> ⼀般语境下，单单前序遍历结果是不能还原⼆叉树结构的，因为缺少空指针的信息，⾄少要得到 前、中、后序遍历中的两种才能还原⼆叉树。

**反序列化过程也是⼀样，先确定根节点 root，然后遵循前序遍历的规则，递归⽣成左右⼦树即可。**

- 297. ⼆叉树的序列化和反序列化（困难）

## 二叉搜索树

BST 是⼀种特殊的⼆叉树，它的两个主要特点：

1、左⼩右⼤，即每个节点的左⼦树都⽐当前节点的值⼩，右⼦树都⽐当前节点的值⼤。

2、**中序遍历结果是有序的（升 序）。**

- 230. BST 第 K ⼩的元素（中等）
- 538. ⼆叉搜索树转化累加树（中等）
- 1038. BST 转累加树（中等）
